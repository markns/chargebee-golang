// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Subscription subscription
// swagger:model Subscription

type Subscription struct {

	// activated at
	ActivatedAt int64 `json:"activated_at,omitempty"`

	// addons
	Addons []*Addon `json:"addons"`

	// affiliate token
	AffiliateToken string `json:"affiliate_token,omitempty"`

	// auto collection
	AutoCollection string `json:"auto_collection,omitempty"`

	// base currency code
	BaseCurrencyCode string `json:"base_currency_code,omitempty"`

	// billing period
	BillingPeriod int32 `json:"billing_period,omitempty"`

	// billing period unit
	BillingPeriodUnit string `json:"billing_period_unit,omitempty"`

	// cancel reason
	CancelReason string `json:"cancel_reason,omitempty"`

	// cancelled at
	CancelledAt int64 `json:"cancelled_at,omitempty"`

	// coupons
	Coupons []*Coupon `json:"coupons"`

	// created at
	CreatedAt int64 `json:"created_at,omitempty"`

	// created from ip
	CreatedFromIP string `json:"created_from_ip,omitempty"`

	// currency code
	CurrencyCode string `json:"currency_code,omitempty"`

	// current term end
	CurrentTermEnd int64 `json:"current_term_end,omitempty"`

	// current term start
	CurrentTermStart int64 `json:"current_term_start,omitempty"`

	// customer id
	CustomerID string `json:"customer_id,omitempty"`

	// deleted
	Deleted bool `json:"deleted,omitempty"`

	// due invoices count
	DueInvoicesCount int32 `json:"due_invoices_count,omitempty"`

	// due since
	DueSince int64 `json:"due_since,omitempty"`

	// exchange rate
	ExchangeRate float64 `json:"exchange_rate,omitempty"`

	// has scheduled changes
	HasScheduledChanges bool `json:"has_scheduled_changes,omitempty"`

	// id
	ID string `json:"id,omitempty"`

	// invoice notes
	InvoiceNotes string `json:"invoice_notes,omitempty"`

	// meta data
	MetaData string `json:"meta_data,omitempty"`

	// mrr
	Mrr int32 `json:"mrr,omitempty"`

	// next billing at
	NextBillingAt int64 `json:"next_billing_at,omitempty"`

	// payment source id
	PaymentSourceID string `json:"payment_source_id,omitempty"`

	// plan free quantity
	PlanFreeQuantity int32 `json:"plan_free_quantity,omitempty"`

	// plan id
	PlanID string `json:"plan_id,omitempty"`

	// plan quantity
	PlanQuantity int32 `json:"plan_quantity,omitempty"`

	// plan unit price
	PlanUnitPrice int32 `json:"plan_unit_price,omitempty"`

	// po number
	PoNumber string `json:"po_number,omitempty"`

	// referral info
	ReferralInfo *ReferralInfo `json:"referral_info,omitempty"`

	// remaining billing cycles
	RemainingBillingCycles int32 `json:"remaining_billing_cycles,omitempty"`

	// resource version
	ResourceVersion int64 `json:"resource_version,omitempty"`

	// setup fee
	SetupFee int32 `json:"setup_fee,omitempty"`

	// shipping address
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`

	// start date
	StartDate int64 `json:"start_date,omitempty"`

	// started at
	StartedAt int64 `json:"started_at,omitempty"`

	// status
	Status string `json:"status,omitempty"`

	// total dues
	TotalDues int32 `json:"total_dues,omitempty"`

	// trial end
	TrialEnd int64 `json:"trial_end,omitempty"`

	// trial start
	TrialStart int64 `json:"trial_start,omitempty"`

	// updated at
	UpdatedAt int64 `json:"updated_at,omitempty"`
}

/* polymorph Subscription activated_at false */

/* polymorph Subscription addons false */

/* polymorph Subscription affiliate_token false */

/* polymorph Subscription auto_collection false */

/* polymorph Subscription base_currency_code false */

/* polymorph Subscription billing_period false */

/* polymorph Subscription billing_period_unit false */

/* polymorph Subscription cancel_reason false */

/* polymorph Subscription cancelled_at false */

/* polymorph Subscription coupons false */

/* polymorph Subscription created_at false */

/* polymorph Subscription created_from_ip false */

/* polymorph Subscription currency_code false */

/* polymorph Subscription current_term_end false */

/* polymorph Subscription current_term_start false */

/* polymorph Subscription customer_id false */

/* polymorph Subscription deleted false */

/* polymorph Subscription due_invoices_count false */

/* polymorph Subscription due_since false */

/* polymorph Subscription exchange_rate false */

/* polymorph Subscription has_scheduled_changes false */

/* polymorph Subscription id false */

/* polymorph Subscription invoice_notes false */

/* polymorph Subscription meta_data false */

/* polymorph Subscription mrr false */

/* polymorph Subscription next_billing_at false */

/* polymorph Subscription payment_source_id false */

/* polymorph Subscription plan_free_quantity false */

/* polymorph Subscription plan_id false */

/* polymorph Subscription plan_quantity false */

/* polymorph Subscription plan_unit_price false */

/* polymorph Subscription po_number false */

/* polymorph Subscription referral_info false */

/* polymorph Subscription remaining_billing_cycles false */

/* polymorph Subscription resource_version false */

/* polymorph Subscription setup_fee false */

/* polymorph Subscription shipping_address false */

/* polymorph Subscription start_date false */

/* polymorph Subscription started_at false */

/* polymorph Subscription status false */

/* polymorph Subscription total_dues false */

/* polymorph Subscription trial_end false */

/* polymorph Subscription trial_start false */

/* polymorph Subscription updated_at false */

// Validate validates this subscription
func (m *Subscription) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddons(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateAutoCollection(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBillingPeriodUnit(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCancelReason(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCoupons(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateReferralInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateShippingAddress(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Subscription) validateAddons(formats strfmt.Registry) error {

	if swag.IsZero(m.Addons) { // not required
		return nil
	}

	for i := 0; i < len(m.Addons); i++ {

		if swag.IsZero(m.Addons[i]) { // not required
			continue
		}

		if m.Addons[i] != nil {

			if err := m.Addons[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var subscriptionTypeAutoCollectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["on","off"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeAutoCollectionPropEnum = append(subscriptionTypeAutoCollectionPropEnum, v)
	}
}

const (
	// SubscriptionAutoCollectionOn captures enum value "on"
	SubscriptionAutoCollectionOn string = "on"
	// SubscriptionAutoCollectionOff captures enum value "off"
	SubscriptionAutoCollectionOff string = "off"
)

// prop value enum
func (m *Subscription) validateAutoCollectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeAutoCollectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateAutoCollection(formats strfmt.Registry) error {

	if swag.IsZero(m.AutoCollection) { // not required
		return nil
	}

	// value enum
	if err := m.validateAutoCollectionEnum("auto_collection", "body", m.AutoCollection); err != nil {
		return err
	}

	return nil
}

var subscriptionTypeBillingPeriodUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["week","month","year"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeBillingPeriodUnitPropEnum = append(subscriptionTypeBillingPeriodUnitPropEnum, v)
	}
}

const (
	// SubscriptionBillingPeriodUnitWeek captures enum value "week"
	SubscriptionBillingPeriodUnitWeek string = "week"
	// SubscriptionBillingPeriodUnitMonth captures enum value "month"
	SubscriptionBillingPeriodUnitMonth string = "month"
	// SubscriptionBillingPeriodUnitYear captures enum value "year"
	SubscriptionBillingPeriodUnitYear string = "year"
)

// prop value enum
func (m *Subscription) validateBillingPeriodUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeBillingPeriodUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateBillingPeriodUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingPeriodUnit) { // not required
		return nil
	}

	// value enum
	if err := m.validateBillingPeriodUnitEnum("billing_period_unit", "body", m.BillingPeriodUnit); err != nil {
		return err
	}

	return nil
}

var subscriptionTypeCancelReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_paid","no_card","fraud_review_failed","non_compliant_eu_customer","tax_calculation_failed","currency_incompatible_with_gateway","non_compliant_customer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeCancelReasonPropEnum = append(subscriptionTypeCancelReasonPropEnum, v)
	}
}

const (
	// SubscriptionCancelReasonNotPaid captures enum value "not_paid"
	SubscriptionCancelReasonNotPaid string = "not_paid"
	// SubscriptionCancelReasonNoCard captures enum value "no_card"
	SubscriptionCancelReasonNoCard string = "no_card"
	// SubscriptionCancelReasonFraudReviewFailed captures enum value "fraud_review_failed"
	SubscriptionCancelReasonFraudReviewFailed string = "fraud_review_failed"
	// SubscriptionCancelReasonNonCompliantEuCustomer captures enum value "non_compliant_eu_customer"
	SubscriptionCancelReasonNonCompliantEuCustomer string = "non_compliant_eu_customer"
	// SubscriptionCancelReasonTaxCalculationFailed captures enum value "tax_calculation_failed"
	SubscriptionCancelReasonTaxCalculationFailed string = "tax_calculation_failed"
	// SubscriptionCancelReasonCurrencyIncompatibleWithGateway captures enum value "currency_incompatible_with_gateway"
	SubscriptionCancelReasonCurrencyIncompatibleWithGateway string = "currency_incompatible_with_gateway"
	// SubscriptionCancelReasonNonCompliantCustomer captures enum value "non_compliant_customer"
	SubscriptionCancelReasonNonCompliantCustomer string = "non_compliant_customer"
)

// prop value enum
func (m *Subscription) validateCancelReasonEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeCancelReasonPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateCancelReason(formats strfmt.Registry) error {

	if swag.IsZero(m.CancelReason) { // not required
		return nil
	}

	// value enum
	if err := m.validateCancelReasonEnum("cancel_reason", "body", m.CancelReason); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateCoupons(formats strfmt.Registry) error {

	if swag.IsZero(m.Coupons) { // not required
		return nil
	}

	for i := 0; i < len(m.Coupons); i++ {

		if swag.IsZero(m.Coupons[i]) { // not required
			continue
		}

		if m.Coupons[i] != nil {

			if err := m.Coupons[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("coupons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Subscription) validateReferralInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.ReferralInfo) { // not required
		return nil
	}

	if m.ReferralInfo != nil {

		if err := m.ReferralInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("referral_info")
			}
			return err
		}
	}

	return nil
}

func (m *Subscription) validateShippingAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.ShippingAddress) { // not required
		return nil
	}

	if m.ShippingAddress != nil {

		if err := m.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipping_address")
			}
			return err
		}
	}

	return nil
}

var subscriptionTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["in_progress","success","voided","failure","timeout","needs_attention"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeStatusPropEnum = append(subscriptionTypeStatusPropEnum, v)
	}
}

const (
	// SubscriptionStatusInProgress captures enum value "in_progress"
	SubscriptionStatusInProgress string = "in_progress"
	// SubscriptionStatusSuccess captures enum value "success"
	SubscriptionStatusSuccess string = "success"
	// SubscriptionStatusVoided captures enum value "voided"
	SubscriptionStatusVoided string = "voided"
	// SubscriptionStatusFailure captures enum value "failure"
	SubscriptionStatusFailure string = "failure"
	// SubscriptionStatusTimeout captures enum value "timeout"
	SubscriptionStatusTimeout string = "timeout"
	// SubscriptionStatusNeedsAttention captures enum value "needs_attention"
	SubscriptionStatusNeedsAttention string = "needs_attention"
)

// prop value enum
func (m *Subscription) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Subscription) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Subscription) UnmarshalBinary(b []byte) error {
	var res Subscription
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
