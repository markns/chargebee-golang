// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Invoice invoice
// swagger:model Invoice
type Invoice struct {

	// adjustment credit notes
	AdjustmentCreditNotes []*AdjustmentCreditNote `json:"adjustment_credit_notes"`

	// amount adjusted
	AmountAdjusted int32 `json:"amount_adjusted,omitempty"`

	// amount due
	AmountDue int32 `json:"amount_due,omitempty"`

	// amount paid
	AmountPaid int32 `json:"amount_paid,omitempty"`

	// amount to collect
	AmountToCollect int32 `json:"amount_to_collect,omitempty"`

	// applied credits
	AppliedCredits []*AppliedCredit `json:"applied_credits"`

	// billing address
	BillingAddress *BillingAddress `json:"billing_address,omitempty"`

	// credits applied
	CreditsApplied int32 `json:"credits_applied,omitempty"`

	// currency code
	CurrencyCode string `json:"currency_code,omitempty"`

	// customer id
	CustomerID string `json:"customer_id,omitempty"`

	// date
	Date int64 `json:"date,omitempty"`

	// deleted
	Deleted bool `json:"deleted,omitempty"`

	// discounts
	Discounts []*Discount `json:"discounts"`

	// due date
	DueDate int64 `json:"due_date,omitempty"`

	// dunning status
	DunningStatus string `json:"dunning_status,omitempty"`

	// first invoice
	FirstInvoice bool `json:"first_invoice,omitempty"`

	// has advance charges
	HasAdvanceCharges bool `json:"has_advance_charges,omitempty"`

	// id
	ID string `json:"id,omitempty"`

	// issued credit notes
	IssuedCreditNotes []*IssuedCreditNote `json:"issued_credit_notes"`

	// line item discounts
	LineItemDiscounts []*LineItemDiscount `json:"line_item_discounts"`

	// line item taxes
	LineItemTaxes []*LineItemTax `json:"line_item_taxes"`

	// line items
	LineItems []*LineItem `json:"line_items"`

	// linked orders
	LinkedOrders []*LinkedOrder `json:"linked_orders"`

	// linked payments
	LinkedPayments []*LinkedPayment `json:"linked_payments"`

	// net term days
	NetTermDays int32 `json:"net_term_days,omitempty"`

	// next retry at
	NextRetryAt int64 `json:"next_retry_at,omitempty"`

	// notes
	Notes []*Note `json:"notes"`

	// paid at
	PaidAt int64 `json:"paid_at,omitempty"`

	// po number
	PoNumber string `json:"po_number,omitempty"`

	// price type
	PriceType string `json:"price_type,omitempty"`

	// recurring
	Recurring bool `json:"recurring,omitempty"`

	// resource version
	ResourceVersion int64 `json:"resource_version,omitempty"`

	// round off amount
	RoundOffAmount int32 `json:"round_off_amount,omitempty"`

	// shipping address
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`

	// status
	Status string `json:"status,omitempty"`

	// sub total
	SubTotal int32 `json:"sub_total,omitempty"`

	// subscription id
	SubscriptionID string `json:"subscription_id,omitempty"`

	// tax
	Tax int32 `json:"tax,omitempty"`

	// taxes
	Taxes []*Tax `json:"taxes"`

	// total
	Total int32 `json:"total,omitempty"`

	// updated at
	UpdatedAt int64 `json:"updated_at,omitempty"`

	// vat number
	VatNumber string `json:"vat_number,omitempty"`

	// voided at
	VoidedAt int64 `json:"voided_at,omitempty"`

	// write off amount
	WriteOffAmount int32 `json:"write_off_amount,omitempty"`
}

// Validate validates this invoice
func (m *Invoice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdjustmentCreditNotes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateAppliedCredits(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBillingAddress(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDiscounts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDunningStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIssuedCreditNotes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLineItemDiscounts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLineItemTaxes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLineItems(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLinkedOrders(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLinkedPayments(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNotes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePriceType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateShippingAddress(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTaxes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Invoice) validateAdjustmentCreditNotes(formats strfmt.Registry) error {

	if swag.IsZero(m.AdjustmentCreditNotes) { // not required
		return nil
	}

	for i := 0; i < len(m.AdjustmentCreditNotes); i++ {

		if swag.IsZero(m.AdjustmentCreditNotes[i]) { // not required
			continue
		}

		if m.AdjustmentCreditNotes[i] != nil {

			if err := m.AdjustmentCreditNotes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("adjustment_credit_notes" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateAppliedCredits(formats strfmt.Registry) error {

	if swag.IsZero(m.AppliedCredits) { // not required
		return nil
	}

	for i := 0; i < len(m.AppliedCredits); i++ {

		if swag.IsZero(m.AppliedCredits[i]) { // not required
			continue
		}

		if m.AppliedCredits[i] != nil {

			if err := m.AppliedCredits[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("applied_credits" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateBillingAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingAddress) { // not required
		return nil
	}

	if m.BillingAddress != nil {

		if err := m.BillingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billing_address")
			}
			return err
		}

	}

	return nil
}

func (m *Invoice) validateDiscounts(formats strfmt.Registry) error {

	if swag.IsZero(m.Discounts) { // not required
		return nil
	}

	for i := 0; i < len(m.Discounts); i++ {

		if swag.IsZero(m.Discounts[i]) { // not required
			continue
		}

		if m.Discounts[i] != nil {

			if err := m.Discounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("discounts" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

var invoiceTypeDunningStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["in_progress","exhausted","stopped","success"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		invoiceTypeDunningStatusPropEnum = append(invoiceTypeDunningStatusPropEnum, v)
	}
}

const (

	// InvoiceDunningStatusInProgress captures enum value "in_progress"
	InvoiceDunningStatusInProgress string = "in_progress"

	// InvoiceDunningStatusExhausted captures enum value "exhausted"
	InvoiceDunningStatusExhausted string = "exhausted"

	// InvoiceDunningStatusStopped captures enum value "stopped"
	InvoiceDunningStatusStopped string = "stopped"

	// InvoiceDunningStatusSuccess captures enum value "success"
	InvoiceDunningStatusSuccess string = "success"
)

// prop value enum
func (m *Invoice) validateDunningStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, invoiceTypeDunningStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Invoice) validateDunningStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.DunningStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateDunningStatusEnum("dunning_status", "body", m.DunningStatus); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateIssuedCreditNotes(formats strfmt.Registry) error {

	if swag.IsZero(m.IssuedCreditNotes) { // not required
		return nil
	}

	for i := 0; i < len(m.IssuedCreditNotes); i++ {

		if swag.IsZero(m.IssuedCreditNotes[i]) { // not required
			continue
		}

		if m.IssuedCreditNotes[i] != nil {

			if err := m.IssuedCreditNotes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("issued_credit_notes" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateLineItemDiscounts(formats strfmt.Registry) error {

	if swag.IsZero(m.LineItemDiscounts) { // not required
		return nil
	}

	for i := 0; i < len(m.LineItemDiscounts); i++ {

		if swag.IsZero(m.LineItemDiscounts[i]) { // not required
			continue
		}

		if m.LineItemDiscounts[i] != nil {

			if err := m.LineItemDiscounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("line_item_discounts" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateLineItemTaxes(formats strfmt.Registry) error {

	if swag.IsZero(m.LineItemTaxes) { // not required
		return nil
	}

	for i := 0; i < len(m.LineItemTaxes); i++ {

		if swag.IsZero(m.LineItemTaxes[i]) { // not required
			continue
		}

		if m.LineItemTaxes[i] != nil {

			if err := m.LineItemTaxes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("line_item_taxes" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateLineItems(formats strfmt.Registry) error {

	if swag.IsZero(m.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(m.LineItems); i++ {

		if swag.IsZero(m.LineItems[i]) { // not required
			continue
		}

		if m.LineItems[i] != nil {

			if err := m.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("line_items" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateLinkedOrders(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkedOrders) { // not required
		return nil
	}

	for i := 0; i < len(m.LinkedOrders); i++ {

		if swag.IsZero(m.LinkedOrders[i]) { // not required
			continue
		}

		if m.LinkedOrders[i] != nil {

			if err := m.LinkedOrders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("linked_orders" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateLinkedPayments(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkedPayments) { // not required
		return nil
	}

	for i := 0; i < len(m.LinkedPayments); i++ {

		if swag.IsZero(m.LinkedPayments[i]) { // not required
			continue
		}

		if m.LinkedPayments[i] != nil {

			if err := m.LinkedPayments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("linked_payments" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Invoice) validateNotes(formats strfmt.Registry) error {

	if swag.IsZero(m.Notes) { // not required
		return nil
	}

	for i := 0; i < len(m.Notes); i++ {

		if swag.IsZero(m.Notes[i]) { // not required
			continue
		}

		if m.Notes[i] != nil {

			if err := m.Notes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("notes" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

var invoiceTypePriceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["tax_exclusive","tax_inclusive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		invoiceTypePriceTypePropEnum = append(invoiceTypePriceTypePropEnum, v)
	}
}

const (

	// InvoicePriceTypeTaxExclusive captures enum value "tax_exclusive"
	InvoicePriceTypeTaxExclusive string = "tax_exclusive"

	// InvoicePriceTypeTaxInclusive captures enum value "tax_inclusive"
	InvoicePriceTypeTaxInclusive string = "tax_inclusive"
)

// prop value enum
func (m *Invoice) validatePriceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, invoiceTypePriceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Invoice) validatePriceType(formats strfmt.Registry) error {

	if swag.IsZero(m.PriceType) { // not required
		return nil
	}

	// value enum
	if err := m.validatePriceTypeEnum("price_type", "body", m.PriceType); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateShippingAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.ShippingAddress) { // not required
		return nil
	}

	if m.ShippingAddress != nil {

		if err := m.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipping_address")
			}
			return err
		}

	}

	return nil
}

var invoiceTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["future","in_trial","active","non_renewing","cancelled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		invoiceTypeStatusPropEnum = append(invoiceTypeStatusPropEnum, v)
	}
}

const (

	// InvoiceStatusFuture captures enum value "future"
	InvoiceStatusFuture string = "future"

	// InvoiceStatusInTrial captures enum value "in_trial"
	InvoiceStatusInTrial string = "in_trial"

	// InvoiceStatusActive captures enum value "active"
	InvoiceStatusActive string = "active"

	// InvoiceStatusNonRenewing captures enum value "non_renewing"
	InvoiceStatusNonRenewing string = "non_renewing"

	// InvoiceStatusCancelled captures enum value "cancelled"
	InvoiceStatusCancelled string = "cancelled"
)

// prop value enum
func (m *Invoice) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, invoiceTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Invoice) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateTaxes(formats strfmt.Registry) error {

	if swag.IsZero(m.Taxes) { // not required
		return nil
	}

	for i := 0; i < len(m.Taxes); i++ {

		if swag.IsZero(m.Taxes[i]) { // not required
			continue
		}

		if m.Taxes[i] != nil {

			if err := m.Taxes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxes" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Invoice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Invoice) UnmarshalBinary(b []byte) error {
	var res Invoice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
