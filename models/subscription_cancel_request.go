// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SubscriptionCancelRequest subscription cancel request
// swagger:model SubscriptionCancelRequest

type SubscriptionCancelRequest struct {

	// account receivables handling
	AccountReceivablesHandling string `json:"account_receivables_handling,omitempty"`

	// credit option for current term charges
	CreditOptionForCurrentTermCharges string `json:"credit_option_for_current_term_charges,omitempty"`

	// end of term
	EndOfTerm bool `json:"end_of_term,omitempty"`

	// refundable credits handling
	RefundableCreditsHandling string `json:"refundable_credits_handling,omitempty"`

	// unbilled charges option
	UnbilledChargesOption string `json:"unbilled_charges_option,omitempty"`
}

/* polymorph SubscriptionCancelRequest account_receivables_handling false */

/* polymorph SubscriptionCancelRequest credit_option_for_current_term_charges false */

/* polymorph SubscriptionCancelRequest end_of_term false */

/* polymorph SubscriptionCancelRequest refundable_credits_handling false */

/* polymorph SubscriptionCancelRequest unbilled_charges_option false */

// Validate validates this subscription cancel request
func (m *SubscriptionCancelRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountReceivablesHandling(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCreditOptionForCurrentTermCharges(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRefundableCreditsHandling(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateUnbilledChargesOption(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var subscriptionCancelRequestTypeAccountReceivablesHandlingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["no_action","schedule_payment_collection","write_off"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionCancelRequestTypeAccountReceivablesHandlingPropEnum = append(subscriptionCancelRequestTypeAccountReceivablesHandlingPropEnum, v)
	}
}

const (
	// SubscriptionCancelRequestAccountReceivablesHandlingNoAction captures enum value "no_action"
	SubscriptionCancelRequestAccountReceivablesHandlingNoAction string = "no_action"
	// SubscriptionCancelRequestAccountReceivablesHandlingSchedulePaymentCollection captures enum value "schedule_payment_collection"
	SubscriptionCancelRequestAccountReceivablesHandlingSchedulePaymentCollection string = "schedule_payment_collection"
	// SubscriptionCancelRequestAccountReceivablesHandlingWriteOff captures enum value "write_off"
	SubscriptionCancelRequestAccountReceivablesHandlingWriteOff string = "write_off"
)

// prop value enum
func (m *SubscriptionCancelRequest) validateAccountReceivablesHandlingEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionCancelRequestTypeAccountReceivablesHandlingPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubscriptionCancelRequest) validateAccountReceivablesHandling(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountReceivablesHandling) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccountReceivablesHandlingEnum("account_receivables_handling", "body", m.AccountReceivablesHandling); err != nil {
		return err
	}

	return nil
}

var subscriptionCancelRequestTypeCreditOptionForCurrentTermChargesPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","prorate","full"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionCancelRequestTypeCreditOptionForCurrentTermChargesPropEnum = append(subscriptionCancelRequestTypeCreditOptionForCurrentTermChargesPropEnum, v)
	}
}

const (
	// SubscriptionCancelRequestCreditOptionForCurrentTermChargesNone captures enum value "none"
	SubscriptionCancelRequestCreditOptionForCurrentTermChargesNone string = "none"
	// SubscriptionCancelRequestCreditOptionForCurrentTermChargesProrate captures enum value "prorate"
	SubscriptionCancelRequestCreditOptionForCurrentTermChargesProrate string = "prorate"
	// SubscriptionCancelRequestCreditOptionForCurrentTermChargesFull captures enum value "full"
	SubscriptionCancelRequestCreditOptionForCurrentTermChargesFull string = "full"
)

// prop value enum
func (m *SubscriptionCancelRequest) validateCreditOptionForCurrentTermChargesEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionCancelRequestTypeCreditOptionForCurrentTermChargesPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubscriptionCancelRequest) validateCreditOptionForCurrentTermCharges(formats strfmt.Registry) error {

	if swag.IsZero(m.CreditOptionForCurrentTermCharges) { // not required
		return nil
	}

	// value enum
	if err := m.validateCreditOptionForCurrentTermChargesEnum("credit_option_for_current_term_charges", "body", m.CreditOptionForCurrentTermCharges); err != nil {
		return err
	}

	return nil
}

var subscriptionCancelRequestTypeRefundableCreditsHandlingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["no_action","schedule_refund"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionCancelRequestTypeRefundableCreditsHandlingPropEnum = append(subscriptionCancelRequestTypeRefundableCreditsHandlingPropEnum, v)
	}
}

const (
	// SubscriptionCancelRequestRefundableCreditsHandlingNoAction captures enum value "no_action"
	SubscriptionCancelRequestRefundableCreditsHandlingNoAction string = "no_action"
	// SubscriptionCancelRequestRefundableCreditsHandlingScheduleRefund captures enum value "schedule_refund"
	SubscriptionCancelRequestRefundableCreditsHandlingScheduleRefund string = "schedule_refund"
)

// prop value enum
func (m *SubscriptionCancelRequest) validateRefundableCreditsHandlingEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionCancelRequestTypeRefundableCreditsHandlingPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubscriptionCancelRequest) validateRefundableCreditsHandling(formats strfmt.Registry) error {

	if swag.IsZero(m.RefundableCreditsHandling) { // not required
		return nil
	}

	// value enum
	if err := m.validateRefundableCreditsHandlingEnum("refundable_credits_handling", "body", m.RefundableCreditsHandling); err != nil {
		return err
	}

	return nil
}

var subscriptionCancelRequestTypeUnbilledChargesOptionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["invoice","delete"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionCancelRequestTypeUnbilledChargesOptionPropEnum = append(subscriptionCancelRequestTypeUnbilledChargesOptionPropEnum, v)
	}
}

const (
	// SubscriptionCancelRequestUnbilledChargesOptionInvoice captures enum value "invoice"
	SubscriptionCancelRequestUnbilledChargesOptionInvoice string = "invoice"
	// SubscriptionCancelRequestUnbilledChargesOptionDelete captures enum value "delete"
	SubscriptionCancelRequestUnbilledChargesOptionDelete string = "delete"
)

// prop value enum
func (m *SubscriptionCancelRequest) validateUnbilledChargesOptionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionCancelRequestTypeUnbilledChargesOptionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubscriptionCancelRequest) validateUnbilledChargesOption(formats strfmt.Registry) error {

	if swag.IsZero(m.UnbilledChargesOption) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnbilledChargesOptionEnum("unbilled_charges_option", "body", m.UnbilledChargesOption); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SubscriptionCancelRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SubscriptionCancelRequest) UnmarshalBinary(b []byte) error {
	var res SubscriptionCancelRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
